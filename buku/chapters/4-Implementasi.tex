\chapter{IMPLEMENTASI}
	Bab ini membahas implementasi sistem Pengendali Elastisitas secara rinci. Pembahasan dilakukan secara rinci untuk setiap komponen yang ada, yaitu: \textit{docker registry}, \textit{master host}, \textit{controller}, \textit{load balancer}, dan dasbor.
    
    \section{Lingkungan Implementasi}
    	Lingkungan implementasi dan pengembangan dilakukan menggunakan virtualisasi Proxmox dengan spesifikasi Host komputer adalah Intel(R) Core(TM) i3-2120 CPU @ 3.30GHz dengan memori 8 GB di Laboratorium Arsitektur dan Jaringan Komputer, Teknik Informatika ITS. Perangkat lunak yang digunakan dalam pengembangan adalah sebagai berikut:
        \begin{itemize}
        \item Sistem Operasi Linux Ubuntu Server 16.04 LTS
        \item RabbitMQ 3.7.5-1
        \item MySQL Ver 15.1 Distrib 10.0.34-MariaDB
        \item Python 2.7
        \item Flask 0.12.2
        \item Node.js v6.11.4
        \item Nagios 4.3.4
        \item Express.js 4.16.3
        \end{itemize}
        
	\section{Implementasi REST API}
    	REST API digunakan untuk memudahkan aplikasi agar ringan dan mudah untuk dikembangkan. pada tugas akhir ini, REST API memiliki fungsi utama untuk menyimpan data user yang berlangganan pada perangkat jaringan atau berlangganan OID (Informasi didalam perangkat jaringan). REST API dibangun dengan framework Python yaitu Flask dan dilengkapi ORM (Object-relational mapping) Database yaitu Peewee.
        \subsection{Pemasangan Python Flask dan Peewee}
        	Pemasangan \texttt{Python Flask} dapat dilakukan dengan mudah, cukup dengan memasangnya dengan manajer paket yang dimiliki oleh \texttt{Python} yaitu \texttt{Pip}. Setelah \texttt{Flask} berhasil terpasang, selanjutnya adalah tahap pemasangan ORM \texttt{Peewee}. \texttt{Peewee} adalah Object-relational Mapping dimana fungsi utamanya adalah memudahkan pengembang agar dapat menyambungkan aplikasi dengan database dan melakukan query dengan mudah. pemasangan ORM Peewee dapat dilakukan dengan cara mengambil berkas instalasinya pada git \url{https://github.com/coleifer/peewee.git} dan pasang Peewee sesuai dengan instruksi yang tertera pada situs git tersebut.
        	
        \subsection{Implementasi Endpoint pada REST API }
        	REST API diakses menggunakan protokol HTTP. Penamaan dan struktur URL yang konsisten akan menghasilkan API yang baik dan mudah untuk dimengerti developer. URL API biasa disebut endpoint dalam pemanggilannya.
        	
        	Pada sistem ini terdapat beberapa endpoint, beberapa endpoint dibagi menjadi beberapa endpoint sesuai dengan perintah yang diajalankannya. misal: create, read, delete, update dan lain-lain.
        	
        	Berikut ini adalah endpoint yang dibuat dalam sistem ini:
        	
        	\begin{longtable}{|p{0.05\textwidth}|p{0.40\textwidth}|p{0.13\textwidth}|p{0.25\textwidth}|} % L = Rata kiri untuk setiap kolom, | = garis batas vertikal.
        		
        		% Kepala tabel, berulang di setiap halaman
        		\caption{Daftar Endpoint pada REST API} \label{tabelEndpointRESTAPI} \\
        		\hline
        		\textbf{No} & \textbf{Endpoint (Route)} & \textbf{Metode} & \textbf{Aksi} \\ \hline
        		\endhead
        		\endfoot
        		\endlastfoot
        		1 & /register & POST & Membuat data baru pada tabel user di database \\ \hline
        		2 & /login & POST & Mengambil data pada tabel user dan mencocokkannya dengan JSON yang dikirimkan lewat body. setelah data username dan password cocok, lalu dibuatkan sebuah token JWT. \\ \hline
        		3 & /logout & POST & Memasukkan token JWT yang terdaftar pada server kedalam daftar hitam agar token tidak dapat digunakan lagi. \\ \hline
        		4 & /users & GET & Menampilkan seluruh data user yang terdaftar pada sistem \\ \hline
        		5 & /users/\textless{}string:username\textgreater{} & GET & Menampilkan data user berdasarkan username yang tertulis pada URL \\ \hline
        		6 & /devices/create & POST & Membuat data baru pada tabel devices di database \\ \hline
        		7 & /devices/edit/\textless{}string:id\textgreater{} & PUT & Mengubah data pada tabel devices di database yang ID nya sama dengan ID yang ada pada URL. \\ \hline
        		8 & /devices/delete & DELETE & Menghapus data pada tabel devices di database yang ID nya tertulis pada body yang bertipe JSON. \\ \hline
        		9 & /devices & GET & Menampilkan seluruh data perangkat yang terdaftar pada sistem \\ \hline
        		10 & /devices/\textless{}string:id\textgreater{} & GET & Menampilkan data user berdasarkan username yang tertulis pada URL \\ \hline
        		11 & /oid/create & POST & Membuat data baru pada tabel oid \\ \hline
        		12 & /oid/edit & POST & Mengubah data pada tabel oid di database yang ID nya tertulis pada body yang bertipe JSON. \\ \hline
        		13 & /oid/delete & POST & Menghapus data pada tabel oid di database yang ID nya tertulis pada body yang bertipe JSON. \\ \hline
        		14 & /subscribe/devices & POST & Membuat data baru pada tabel subscribe \\ \hline
        		15 & /unsubscribe/devices & POST & Menghapus data pada tabel subscribe di database yang ID nya tertulis pada body yang bertipe JSON. \\ \hline
        		16 & /subscribe/oid & POST & Membuat data baru pada tabel subscribe\_oid \\ \hline
        		17 & /unsubscribe/oid & POST & Menghapus data pada tabel subscribe\_oid di database yang ID nya tertulis pada body yang bertipe JSON. \\ \hline	
        	\end{longtable}
        	
    
    \section{Implementasi Publisher Server}
    	Publisher server merupakan server yang berfungsi untuk mengambil data pada perangkat jaringan secara berkala dan mengirimkannya menuju pub/sub server. publisher server menggunakan plugin \texttt{check\_snmp} bawaan program Nagios, Sehingga untuk melakukan pengambilan data, kita perlu memasang nagios pada server.
    	
    	setelah data berhasil dikumpulkan, data yang diambil pada tiap perangkat dikirimkan menuju pub/pub server melalui thread yang berbeda. proses ini dinamakan \texttt{multithreading}.
    		\subsection{Pemasangan Nagios Sebagai Pemantau dan Pengumpul Data Perangkat}
    			Pemasangan \texttt{Nagios} dapat dilakukan dengan beberapa cara, namun cara yang dipakai pada kasus ini adalah memasang \texttt{Nagios} langsung dari sumbernya untuk mendapatkan fitur terbaru, pembaharuan keamanan, dan pembetulan bug.
    			
    			Berikut ini adalah sumber untuk mendapatkan nagios yang siap untuk dipasang: \url{https://assets.nagios.com/downloads/nagioscore/releases/nagios-4.3.4.tar.gz}
    			
    			\texttt{Nagios} perlu beberapa perintah khusus yang hanyak bisa dilakukan oleh user yang bernama "nagios" maka dari itu diperlukan user pada server yang bernama "nagios" dengan nama group "nagcmd". Selain user, \texttt{Nagios} juga perlu beberapa paket yang harus terpasang sebelum memasang nagios itu sendiri. Beberapa paket diantaranya adalah: \texttt{build-essential, libgd2-xpm-dev, openssl, libssl-dev, unzip}
    			
    			Setelah \texttt{Nagios} terpasang, direktori kerja dari Nagios dapat dilihat pada direktori \texttt{/usr/local/nagios}

			\subsection{Pengumpulan Data dan Pembuatan Script Pengiriman}
				Untuk mengumpulkan data perangkat jaringan, dibutuhkan plugin bawaan nagios yang bernama \texttt{check\_snmp}. plugin tersebut berada pada direktori \texttt{/usr/local/nagios/libexec} untuk menjalankan plugin tersebut dibutuhkan dua parameter, yaitu: alamat dari perangkat jaringan yang ingin dipantau dan OID dari data yang ingin didapatkan dari perangkat.
				perintah yang dijalankan untuk mendapatkan data pada perangkat jaringan lewat protokol SNMP adalah seeprti yang tertulis pada kode sumber 
				
\begin{lstlisting}[frame=single,breaklines,caption={Perintah Mengumpulkan Data Perangkat dengan SNMP},label=snmpcommand, captionpos=b]
$ /usr/local/nagios/check_snmp -H <alamat_perangkat> -o <oid_perangkat>
\end{lstlisting}
    			
    			Setelah data dapat dikumpulkan, sebuah script diperlukan untuk mengirim data tersebut menuju pub/sub server yang didukung boleh RabbitMQ sebagai Message Broker.
    			
    			Sebuah library bernama \texttt{pika} dibutuhkan untuk mengirim data tersebut ke pub/sub server. tiap perangkat yang dikumpulkan datanya dan dikirimkan ke pub/sub server, diproses didalam sebuah thread yang berbeda. oleh karena itu inisiasi database dibutuhkan pada awal script untuk menggetahui ada berapa perangkat yang terdaftar pada sistem.
    			
    			pertama-tama, masukkan library yang dibutuhkan untuk pembuatan script (termasuk pika), lalu dilanjutkan dengan potongan kode untuk menginisiasi database. Pseudocode untuk inisasi kelas database dapat dilihat pada kode sumber \ref{pseudo:dbclass}
    			
\begin{lstlisting}[frame=single,breaklines,caption={Pseudocode inisiasi Kelas Database},label=pseudo:dbclass, captionpos=b]
class BaseModel(Model):
class Meta:
database = database

class Users(BaseModel):
id = UUIDField(primary_key=True)
name = CharField()
username = CharField(unique=True)
password = CharField()
email = CharField()
role = CharField()

class Devices(BaseModel):
id = UUIDField(primary_key=True)
name = CharField()
type = CharField()
location = CharField()
address = CharField()

class Oid(BaseModel):
id = UUIDField(primary_key=True)
oid = CharField()
oidname = CharField()
devices_id = ForeignKeyField(Devices, on_delete='CASCADE')

class Subscribe(BaseModel):
users_id = ForeignKeyField(Users, on_delete='CASCADE')
devices_id = ForeignKeyField(Devices, on_delete='CASCADE')
\end{lstlisting}
    			
    			Setelah itu buat fungsi sebagai target menjalankan thread, nantinya tiap thread akan mengeksekusi kode yang ada didalam fungsi tersebut. didalam fungsi tersebut meliputi pegumpulan data dengan \texttt{check\_snmp}. Data perangkat jaringan yang dikumpulkan dengan \texttt{check\_snmp} dimasukkan kedalam sebuah \texttt{python dictionary} yang nantinya dictionary tersebut akan dikirimkan menuju pub/sub server. Pseudocode fungsi tersebut dapat dilihat pada kode sumber \ref{pseudo:threadtarget}
    			
\begin{lstlisting}[frame=single,breaklines,caption={Pseudocode Target \textit{Thread} Untuk Mengambil Data Perangkat},label=pseudo:threadtarget, captionpos=b]
rabbitMq(exchange, address):
	try:
		add getOidData() into array of dictionary
	except:
		add NULL into array of dictionary
	
	try:
		add getSnmpDeviceData() into JSON
	except:
		add Error Message into JSON		
\end{lstlisting}
    			
    			Untuk mengirimkan data menuju pub/sub server diperlukan library pika yang akan membuat koneksi dengan RabbitMQ yang berada di pub/sub server. potongan kode untuk mengirimkan data tersebut dapat dilihat pada kode sumber \ref{pseudo:pika}
    			
\begin{lstlisting}[frame=single,breaklines,caption={Pseudocode Pengiriman Data Dengan Pika},label=pseudo:pika, captionpos=b]
pika.openConnection()
if exchange does not exist:
	createExchage()
	if queue does not exist:
		createQueue()
		bindExchangetoQueue()
	else:
		bindExchangetoQueue()
else:
	pass
sendMessage()
\end{lstlisting}
    			
				Setelah seluruh fungsi selesai dibuat, langkah terakhir adalah membuat thread agar tiap thread nantinya akan mejalankan fungsi yang telah dibuat dan menjalankannya secara berkala. Pseudocode untuk membuat thread dapat dilihat pada kode sumber \ref{pseudo:runthread}
				
\begin{lstlisting}[frame=single,breaklines,caption={Pseudocode Menjalankan Thread},label=pseudo:runthread, captionpos=b]
Thread
while true:
	getDeviceId() as exchangename
	getDeviceAddress as deviceaddress
	thread(target=rabbitmq(), argument=(exchangename, deviceaddress))
	sleep(2)

\end{lstlisting}

    \section{Implementasi Pub/Sub Server}
    	Pada pub/sub server, dipasang aplikasi message broker \texttt{RabbitMQ}. pada kasus ini \texttt{RabbitMQ} menerima seluruh dapat yang dikirmkan oleh publisher. Setelah itu \texttt{RabbitMQ} menyimpannya dan menunggu hingga ada consumer yang meminta data pada \texttt{RabbitMQ}. kriteria data yang dikirimkan harus dispesifikkan sesuai dengan apa yang diminta oleh consumer.
    	
    	Pemasangan aplikasi \texttt{RabbitMQ} membutuhkan bahasa pemrograman \texttt{erlang}. untuk itu sebelum memasang \texttt{RabbitMQ}, harus terlebih dahulu memasang \texttt{erlang} pada sistem. Selain \texttt{erlang}, beberapa paket juga harus terpasang pada sistem, beberapa diantaranya adalah: \texttt{init-system-helpers, socat, adduser, logrotate}
    	
    	Setelah \texttt{RabbitMQ} server terpasang, selanjutnya dibutuhkan sebuah web admin untuk \texttt{RabbitMQ} agar mudah untuk melakukan manajemen data, user dan lain-lain pada web admin tersebut. \texttt{RabbitMQ} sudah menyediakan \textit{plugin} agar web admin dapat langsung digunakan. hanya dengan menjalankan perintah untuk mengaktifkan web admin dengan \texttt{rabbitmqctl}
    
    \section{Implementasi Consumer pada Application Server dan Websocket}
		Sebagai media penyimpn
    \section{Implementasi Database Server}
    	Sebagai media penyimpanan, sebuah database diperlukan untuk menyimpan data pengguna, perangkat, dan data berlangganan. Terdapat tiga tabel utama yang mewakili tiap entitas yang terlibat dalam sistem ini, yaitu: \texttt{users}, \texttt{devices}, dan \texttt{oid}. selain itu, terdapat dua table \texttt{many-to-many} untuk menyimpan data pengguna yang telah berlangganan kepada tiap perangkat dan pengguna yang berlangganan kepada tiap OID (untuk mengetahui informasi apa saja yang ada pada tiap perangkat. tiap OID memiliki informasi yang berbeda).
    	
    	Pada Tugas Akhir ini, sistem basis data yang digunakan adalah \texttt{Mysql Server} yang dimana \texttt{Mysql Server} termasuk kedalam RDBMS (\textit{Relational Database Management System}). Berikut adalah rincian dari tabel yang diimplementasikan. rincian tabel \texttt{users} dapat dilihat pada tabel \ref{tabeldbusers}
    	
    	\begin{longtable}{|p{0.05\textwidth}|p{0.20\textwidth}|p{0.22\textwidth}|p{0.35\textwidth}|} % L = Rata kiri untuk setiap kolom, | = garis batas vertikal.
    		
    		% Kepala tabel, berulang di setiap halaman
    		\caption{Rincian Tabel \texttt{users} pada Database} \label{tabeldbusers} \\
    		\hline
    		\textbf{No} & \textbf{Kolom} & \textbf{Tipe Data} & \textbf{Keterangan} \\ \hline
    		\endhead
    		\endfoot
    		\endlastfoot
    		1 & id & varchar(255) & Sebagai primary key pada tabel, nilai pada kolom ini berformat UUID versi 4 \\ \hline
    		2 & name & varchar(255) & Data yang berbentuk string. Digunakan untuk kelengkapan profil pengguna. \\ \hline
    		3 & username & varchar(255) & Data yang berbentuk string. Digunakan untuk keperluan autentikasi. \\ \hline
    		4 & password & varchar(255) & Data yang berbentuk string, implementasinya berupa hash. Digunakan untuk keperluan autentikasi. \\ \hline
    		5 & email & varchar(255) & Data yang berbentuk string. Digunakan untuk kelengkapan profil pengguna \\ \hline
    		6 & role & varchar(255) & Data yang berbentuk string. Digunakan untuk kelengkapan profil pengguna dan pembeda peran agar setiap user memiliki hak istimewa masing-masing. \\ \hline
    	\end{longtable}
    	
    	\begin{longtable}{|p{0.05\textwidth}|p{0.20\textwidth}|p{0.22\textwidth}|p{0.35\textwidth}|} % L = Rata kiri untuk setiap kolom, | = garis batas vertikal.
    		
    		% Kepala tabel, berulang di setiap halaman
    		\caption{Rincian Tabel \texttt{devices} pada Database} \label{tabeldbdevices} \\
    		\hline
    		\textbf{No} & \textbf{Kolom} & \textbf{Tipe Data} & \textbf{Keterangan} \\ \hline
    		\endhead
    		\endfoot
    		\endlastfoot
    		1 & id & varchar(255) & Sebagai primary key pada tabel, nilai pada kolom ini berformat UUID versi 4 \\ \hline
    		2 & name & varchar(255) & Data yang berbentuk string. Digunakan untuk kelengkapan profil dari perangkat jaringan. \\ \hline
    		3 & type & varchar(255) & Data yang berbentuk string. Digunakan untuk kelengkapan profil dari perangkat jaringan. \\ \hline
    		4 & location & varchar(255) & Data yang berbentuk string. Digunakan untuk kelengkapan profil dari perangkat jaringan. \\ \hline
    		5 & address & varchar(255) & Data yang berbentuk string, implementasinya barbentuk alamat IP dari tiap perangkat jaringan. Digunakan untuk mengkoleksi data pada publisher server. \\ \hline
    	\end{longtable}
    
    	\begin{longtable}{|p{0.05\textwidth}|p{0.20\textwidth}|p{0.22\textwidth}|p{0.35\textwidth}|} % L = Rata kiri untuk setiap kolom, | = garis batas vertikal.
    		
    		% Kepala tabel, berulang di setiap halaman
    		\caption{Rincian Tabel \texttt{OID} pada Database} \label{tabeldboid} \\
    		\hline
    		\textbf{No} & \textbf{Kolom} & \textbf{Tipe Data} & \textbf{Keterangan} \\ \hline
    		\endhead
    		\endfoot
    		\endlastfoot
    		1 & id & varchar(255) & Sebagai primary key pada tabel, nilai pada kolom ini berformat UUID versi 4 \\ \hline
    		2 & oid & varchar(255) & Data yang berbentuk string, implementasinya berbentuk OID (Object-Identifier). Digunakan mengkoleksi perangkat jaringan pada publisher server. \\ \hline
    		3 & oidname & varchar(255) & Data yang berbentuk string. Digunakan untuk kelengkapan profil dari perangkat jaringan. \\ \hline
    		4 & devices\_id & varchar(255) & Merupakan foreign key dari id pata tabel \texttt{devices}. Data ini berbentuk string, nilai pada kolom ini berformat UUID versi 4. \\ \hline
    	\end{longtable}
    
    	\begin{longtable}{|p{0.05\textwidth}|p{0.20\textwidth}|p{0.22\textwidth}|p{0.35\textwidth}|} % L = Rata kiri untuk setiap kolom, | = garis batas vertikal.
    		
    		% Kepala tabel, berulang di setiap halaman
    		\caption{Rincian Tabel \texttt{subscribe} pada Database} \label{tabeldbsubscribe} \\
    		\hline
    		\textbf{No} & \textbf{Kolom} & \textbf{Tipe Data} & \textbf{Keterangan} \\ \hline
    		\endhead
    		\endfoot
    		\endlastfoot
    		1 & users\_id & varchar(255) & Sebagai primary key pada tabel juga sebagai foreign key dari id pada tabel \texttt{users}, nilai pada kolom ini berformat UUID versi 4 \\ \hline
    		2 & devices\_id & varchar(255) & Sebagai primary key pada tabel juga sebagai foreign key dari id pada tabel \texttt{devices}, nilai pada kolom ini berformat UUID versi 4. \\ \hline
    	\end{longtable}
    
    	\begin{longtable}{|p{0.05\textwidth}|p{0.20\textwidth}|p{0.22\textwidth}|p{0.35\textwidth}|} % L = Rata kiri untuk setiap kolom, | = garis batas vertikal.
    		
    		% Kepala tabel, berulang di setiap halaman
    		\caption{Rincian Tabel \texttt{subscribeoid} pada Database} \label{tabeldbsubscribeoid} \\
    		\hline
    		\textbf{No} & \textbf{Kolom} & \textbf{Tipe Data} & \textbf{Keterangan} \\ \hline
    		\endhead
    		\endfoot
    		\endlastfoot
    		1 & users\_id & varchar(255) & Sebagai primary key pada tabel juga sebagai foreign key dari id pada tabel \texttt{users}, nilai pada kolom ini berformat UUID versi 4 \\ \hline
    		2 & oid\_id & varchar(255) & Sebagai primary key pada tabel juga sebagai foreign key dari id pada tabel \texttt{oid}, nilai pada kolom ini berformat UUID versi 4. \\ \hline
    	\end{longtable} 

    \section{Implementasi Antarmuka}
    	Dasbor diimplementasikan menggunankan perangkat kerja React bagian \textit{frontend} dan Flask untuk \textit{backend}nya. Dasbor digunakan untuk mempermudah pengembang dalam mengelola aplikasi. Dasbor memiliki menu-menu sebagai berikut:
        \begin{itemize}
        \item Daftar Aplikasi
        \item Infromasi Aplikasi
        \item Daftar \textit{Container}
        \item Matrik Aplikasi
        \end{itemize}
        \indent Masing-masing menu berikutnya akan dijelaskan secara rinci.
		\subsection{Daftar Aplikasi}
        	Daftar aplikasi, juga merupakan beranda dari dasbor, adalah menu yang digunakan untuk melihat daftar aplikasi atau \textit{image} yang ada pada \textit{server docker registry}. Pada halaman ini, bisa dilihat nama beserta versi terakhir dari aplikasi. Lalu juga terdapat status apakah aplikasi sedang berjalan atau tidak. Antar muka kelola daftar aplikasi ditunjukkan pada Gambar \ref{ddaftaraplikasi}.
			\begin{figure}[H]
				\centering
				\includegraphics[width=11.2cm,height=3.7cm]{Images/C-4/dasberanda.PNG}
				\caption{Dasbor Daftar Aplikasi}
				\label{ddaftaraplikasi}
			\end{figure}
            
         \subsection{Informasi Aplikasi}
         	\begin{figure}[H]
				\centering
				\includegraphics[width=11.2cm,height=9cm]{Images/C-4/dasinformasi.PNG}
				\caption{Dasbor Informasi Aplikasi}
				\label{dinformasiaplikasi}
			\end{figure}
         	Halaman ini menunjukkan infromasi lengkap dari sebuah aplikasi. Pada halaman ini bisa dilihat nama aplikasi, port yang digunakan, domain dari aplikasi, dan versi dari aplikasi. Pada halaman ini, pengguna bisa mengatur port dari aplikasi agar dapat berjalan dengan baik. Dari halaman ini juga aplikasi pertama kali akan dijalankan. Jadi pada halaman ini terdapat kontrol untuk menajalankan dan mematikan aplikasi. Antar muka informasi ditunjukkan pada Gambar \ref{dinformasiaplikasi}.
            
         \subsection{Daftar \textit{Container}}
         	Pada halaman ini, pengguna dapat melihat daftar \textit{container} yang sedang berjalan untuk sebuah aplikasi. Informasi yang diberikan berupa ID dan port dari container. Antar muka halaman daftar \textit{container} ditunjukkan pada Gambar \ref{ddaftarcontainer}.
            \begin{figure}[H]
				\centering
				\includegraphics[width=11.2cm,height=3cm]{Images/C-4/dasdafcont.PNG}
				\caption{Dasbor Daftar \textit{Container}}
				\label{ddaftarcontainer}
			\end{figure}
            
         \subsection{Metrik Aplikasi}
         	Halaman metrik aplikasi digunakan untuk memantau keadaan sekarang dari aplikasi. Metrik yang diberikan adalah jumlah \textit{request} pengguna ke aplikasi dan jumlah \textit{container} dari aplikasi. Data akan diperbarui sekitar lima detik sekali. Antar muka metrik aplikasi ditunjukkan pada Gambar \ref{dmatrikaplikasi}.
            \begin{figure}[H]
				\centering
				\includegraphics[width=11.2cm,height=7.3cm]{Images/C-4/dasmatrik.PNG}
				\caption{Dasbor Matrik Aplikasi}
				\label{dmatrikaplikasi}
			\end{figure}